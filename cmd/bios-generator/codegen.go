package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"sort"
	"strings"
	"text/template"
	"time"
)

const codeTemplate = `// Code generated by bios-generator. DO NOT EDIT.
// Source: https://github.com/libretro/libretro-super/tree/master/dist/info
// Generated: {{.Timestamp}}

package constants

// LibretroCoreToBIOS maps normalized core names to their BIOS requirements
var LibretroCoreToBIOS = map[string]CoreBIOS{
{{range .Cores}}	"{{.CoreName}}": {
		CoreName:    "{{.FullCoreName}}",
		DisplayName: "{{.DisplayName}}",
		Files: []BIOSFile{
{{range .Files}}			{
				FileName:     "{{.FileName}}",
				RelativePath: "{{.RelativePath}}",
				MD5Hash:      "{{.MD5Hash}}",
				Description:  {{.Description}},
				Optional:     {{.Optional}},
			},
{{end}}		},
	},
{{end}}}

// PlatformToLibretroCores maps RomM platform slugs to compatible Libretro cores
var PlatformToLibretroCores = map[string][]string{
{{range .Platforms}}	"{{.Slug}}": { {{range .Cores}}"{{.}}", {{end}} },
{{end}}}

// BIOSFileCount returns the total number of BIOS files across all cores
func BIOSFileCount() int {
	count := 0
	for _, core := range LibretroCoreToBIOS {
		count += len(core.Files)
	}
	return count
}
`

// TemplateData holds data for code generation template
type TemplateData struct {
	Timestamp string
	Cores     []TemplateCoreData
	Platforms []TemplatePlatformData
}

// TemplateCoreData holds core data for template
type TemplateCoreData struct {
	CoreName     string
	FullCoreName string
	DisplayName  string
	Files        []TemplateBIOSFileData
}

// TemplateBIOSFileData holds BIOS file data for template
type TemplateBIOSFileData struct {
	FileName     string
	RelativePath string
	MD5Hash      string
	Description  string
	Optional     string
}

// TemplatePlatformData holds platform data for template
type TemplatePlatformData struct {
	Slug  string
	Cores []string
}

// CodeGenerator generates Go source code
type CodeGenerator struct {
	outputPath string
}

// NewCodeGenerator creates a new CodeGenerator
func NewCodeGenerator(outputPath string) *CodeGenerator {
	return &CodeGenerator{
		outputPath: outputPath,
	}
}

// Generate creates the generated Go source file
func (g *CodeGenerator) Generate(cores map[string]*ParsedCore, platformToCores map[string][]string) error {
	// Prepare template data
	templateData := g.prepareTemplateData(cores, platformToCores)

	// Execute template
	tmpl, err := template.New("code").Parse(codeTemplate)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, templateData); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, write unformatted code for debugging
		fmt.Printf("Warning: code formatting failed: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file
	if err := os.WriteFile(g.outputPath, formatted, 0644); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	fmt.Printf("Generated code written to %s\n", g.outputPath)
	return nil
}

// prepareTemplateData converts parsed data into template-friendly format
func (g *CodeGenerator) prepareTemplateData(cores map[string]*ParsedCore, platformToCores map[string][]string) TemplateData {
	// Prepare cores data (sorted by core name for deterministic output)
	var coreNames []string
	for coreName := range cores {
		coreNames = append(coreNames, coreName)
	}
	sort.Strings(coreNames)

	var templateCores []TemplateCoreData
	for _, coreName := range coreNames {
		core := cores[coreName]

		var templateFiles []TemplateBIOSFileData
		for _, file := range core.Files {
			// Escape description string for Go code
			escapedDesc := fmt.Sprintf("%q", file.Description)

			templateFiles = append(templateFiles, TemplateBIOSFileData{
				FileName:     file.FileName,
				RelativePath: file.RelativePath,
				MD5Hash:      file.MD5Hash,
				Description:  escapedDesc,
				Optional:     fmt.Sprintf("%t", file.Optional),
			})
		}

		templateCores = append(templateCores, TemplateCoreData{
			CoreName:     coreName,
			FullCoreName: core.CoreName,
			DisplayName:  escapeString(core.DisplayName),
			Files:        templateFiles,
		})
	}

	// Prepare platforms data (sorted by slug for deterministic output)
	var platformSlugs []string
	for slug := range platformToCores {
		platformSlugs = append(platformSlugs, slug)
	}
	sort.Strings(platformSlugs)

	var templatePlatforms []TemplatePlatformData
	for _, slug := range platformSlugs {
		coreList := platformToCores[slug]

		// Sort cores for this platform for deterministic output
		sort.Strings(coreList)

		templatePlatforms = append(templatePlatforms, TemplatePlatformData{
			Slug:  slug,
			Cores: coreList,
		})
	}

	return TemplateData{
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Cores:     templateCores,
		Platforms: templatePlatforms,
	}
}

// escapeString escapes special characters in strings for Go code
func escapeString(s string) string {
	// Replace backslashes and quotes
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	return s
}
